# 🌳 اجتياز الأشجار الثنائية - دليل شامل

## 📋 جدول المحتويات
- [🎯 مقدمة](#-مقدمة)
- [🔍 أنواع الاجتياز](#-أنواع-الاجتياز)
- [🌲 بناء الشجرة مع مثال](#-بناء-الشجرة-مع-مثال)
- [📝 مثال عملي](#-مثال-عملي)
- [💻 التطبيق في C++](#-التطبيق-في-c)

---

## 🎯 مقدمة

**اجتياز الأشجار الثنائية** هي طرق لزيارة جميع عقد الشجرة بترتيب محدد. يوجد ثلاثة أنواع رئيسية:

1. **المسبق (Pre-order)** : الجذر ← اليسار ← اليمين
2. **المتوسط (In-order)** : اليسار ← الجذر ← اليمين  
3. **اللاحق (Post-order)** : اليسار ← اليمين ← الجذر

---

## 🔍 أنواع الاجتياز

### 🔸 الاجتياز المسبق (Pre-order)
**الترتيب :** `الجذر ← الشجرة الفرعية اليسرى ← الشجرة الفرعية اليمنى`

**الاستخدامات :**
- إنشاء نسخة من الشجرة
- تسلسل الشجرة
- التعبيرات المسبقة (الترميز البولندي)

### 🔸 الاجتياز المتوسط (In-order)
**الترتيب :** `الشجرة الفرعية اليسرى ← الجذر ← الشجرة الفرعية اليمنى`

**الاستخدامات :**
- **شجرة البحث الثنائية (BST)** : يعطي القيم **مرتبة**
- تقييم التعبيرات الرياضية
- الأكثر استخداماً لعرض القيم بترتيب تصاعدي

### 🔸 الاجتياز اللاحق (Post-order)
**الترتيب :** `الشجرة الفرعية اليسرى ← الشجرة الفرعية اليمنى ← الجذر`

**الاستخدامات :**
- حذف الشجرة (تحرير الذاكرة)
- حساب حجم الشجرة
- التعبيرات اللاحقة (الترميز البولندي العكسي)

---

## 🌲 بناء الشجرة مع مثال

### 📊 البيانات : `20, 30, 10, 5, 6, 1, 4`

لنبني **شجرة البحث الثنائية (BST)** بإدراج القيم بالترتيب:

#### الخطوة 1 : إدراج 20 (الجذر)
```
    20
```

#### الخطوة 2 : إدراج 30 (30 > 20 ← يمين)
```
    20
      \
      30
```

#### الخطوة 3 : إدراج 10 (10 < 20 ← يسار)
```
    20
   /  \
  10   30
```

#### الخطوة 4 : إدراج 5 (5 < 20, 5 < 10 ← يسار من 10)
```
    20
   /  \
  10   30
 /
5
```

#### الخطوة 5 : إدراج 6 (6 < 20, 6 < 10, 6 > 5 ← يمين من 5)
```
    20
   /  \
  10   30
 /
5
 \
  6
```

#### الخطوة 6 : إدراج 1 (1 < 20, 1 < 10, 1 < 5 ← يسار من 5)
```
    20
   /  \
  10   30
 /
5
/\
1  6
```

#### الخطوة 7 : إدراج 4 (4 < 20, 4 < 10, 4 < 5, 4 > 1 ← يمين من 1)
```
    20
   /  \
  10   30
 /
5
/\
1  6
 \
  4
```

### 🎯 الشجرة النهائية
```
        20
       /  \
      10   30
     /
    5
   / \
  1   6
   \
    4
```

---

## 📝 مثال عملي

### 🔸 الاجتياز المسبق (Pre-order)
**الترتيب :** الجذر ← اليسار ← اليمين

**النتيجة :** `20, 10, 5, 1, 4, 6, 30`

**الشرح :**
1. زيارة **20** (الجذر)
2. الذهاب يساراً : زيارة **10**
3. الذهاب يساراً من 10 : زيارة **5**
4. الذهاب يساراً من 5 : زيارة **1**
5. الذهاب يميناً من 1 : زيارة **4**
6. العودة إلى 5، الذهاب يميناً : زيارة **6**
7. العودة إلى 20، الذهاب يميناً : زيارة **30**

### 🔸 الاجتياز المتوسط (In-order)
**الترتيب :** اليسار ← الجذر ← اليمين

**النتيجة :** `1, 4, 5, 6, 10, 20, 30`

**الشرح :**
1. الذهاب أقصى اليسار : زيارة **1**
2. الصعود لوالد 1، الذهاب يميناً : زيارة **4**
3. الصعود لوالد 1 و 4 : زيارة **5**
4. الذهاب يميناً من 5 : زيارة **6**
5. الصعود لوالد 5 : زيارة **10**
6. الصعود للجذر : زيارة **20**
7. الذهاب يميناً من 20 : زيارة **30**

> **⚠️ ملاحظة مهمة :** بالنسبة لـ BST، الاجتياز المتوسط يعطي **دائماً** القيم **مرتبة** !

### 🔸 الاجتياز اللاحق (Post-order)
**الترتيب :** اليسار ← اليمين ← الجذر

**النتيجة :** `4, 1, 6, 5, 10, 30, 20`

**الشرح :**
1. الذهاب أقصى اليسار، ثم يميناً : زيارة **4**
2. الصعود لوالد 4 : زيارة **1**
3. الصعود، الذهاب يميناً : زيارة **6**
4. الصعود لوالد 1 و 6 : زيارة **5**
5. الصعود لوالد 5 : زيارة **10**
6. الصعود، الذهاب يميناً : زيارة **30**
7. أخيراً، زيارة الجذر : زيارة **20**

---

## 💻 التطبيق في C++

```cpp
#include <iostream>
using namespace std;

struct Aqda {  // عقدة
    int data;
    Aqda* yesar;   // يسار
    Aqda* yameen;  // يمين
    
    Aqda(int val) : data(val), yesar(nullptr), yameen(nullptr) {}
};

class ShajarahThunayah {  // شجرة ثنائية
public:
    Aqda* jadr;  // جذر
    
    ShajarahThunayah() : jadr(nullptr) {}
    
    // الإدراج في BST
    Aqda* idraj(Aqda* aqda, int val) {
        if (aqda == nullptr) {
            return new Aqda(val);
        }
        
        if (val < aqda->data) {
            aqda->yesar = idraj(aqda->yesar, val);
        } else {
            aqda->yameen = idraj(aqda->yameen, val);
        }
        
        return aqda;
    }
    
    // الاجتياز المسبق (Pre-order)
    void musabaq(Aqda* aqda) {
        if (aqda != nullptr) {
            cout << aqda->data << " ";    // زيارة الجذر
            musabaq(aqda->yesar);         // الاجتياز يساراً
            musabaq(aqda->yameen);        // الاجتياز يميناً
        }
    }
    
    // الاجتياز المتوسط (In-order)
    void mutawasit(Aqda* aqda) {
        if (aqda != nullptr) {
            mutawasit(aqda->yesar);       // الاجتياز يساراً
            cout << aqda->data << " ";    // زيارة الجذر
            mutawasit(aqda->yameen);      // الاجتياز يميناً
        }
    }
    
    // الاجتياز اللاحق (Post-order)
    void lahiq(Aqda* aqda) {
        if (aqda != nullptr) {
            lahiq(aqda->yesar);           // الاجتياز يساراً
            lahiq(aqda->yameen);          // الاجتياز يميناً
            cout << aqda->data << " ";    // زيارة الجذر
        }
    }
};

int main() {
    ShajarahThunayah shajarah;
    
    // إدراج القيم : 20, 30, 10, 5, 6, 1, 4
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 20);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 30);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 10);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 5);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 6);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 1);
    shajarah.jadr = shajarah.idraj(shajarah.jadr, 4);
    
    cout << "الشجرة المبنية بالقيم : 20, 30, 10, 5, 6, 1, 4\n\n";
    
    cout << "الاجتياز المسبق (Pre-order) : ";
    shajarah.musabaq(shajarah.jadr);
    cout << "\n";
    
    cout << "الاجتياز المتوسط (In-order) : ";
    shajarah.mutawasit(shajarah.jadr);
    cout << "\n";
    
    cout << "الاجتياز اللاحق (Post-order) : ";
    shajarah.lahiq(shajarah.jadr);
    cout << "\n";
    
    return 0;
}
```

### 📊 نتيجة التشغيل :
```
الشجرة المبنية بالقيم : 20, 30, 10, 5, 6, 1, 4

الاجتياز المسبق (Pre-order) : 20 10 5 1 4 6 30 
الاجتياز المتوسط (In-order) : 1 4 5 6 10 20 30 
الاجتياز اللاحق (Post-order) : 4 1 6 5 10 30 20 
```

---

## 🎯 الملخص

| نوع الاجتياز | الترتيب | الاستخدام الرئيسي | النتيجة لمثالنا |
|---------------|---------|-------------------|-------------------|
| **المسبق** | الجذر ← اليسار ← اليمين | النسخ/التسلسل | `20, 10, 5, 1, 4, 6, 30` |
| **المتوسط** | اليسار ← الجذر ← اليمين | **الترتيب (BST)** | `1, 4, 5, 6, 10, 20, 30` |
| **اللاحق** | اليسار ← اليمين ← الجذر | الحذف/الحساب | `4, 1, 6, 5, 10, 30, 20` |

> **💡 نصيحة :** بالنسبة لـ BST، استخدم دائماً الاجتياز **المتوسط** للحصول على القيم مرتبة !

---

## 🔍 شرح إضافي للمفاهيم

### 🌟 لماذا الاجتياز المتوسط مهم في BST؟

في **شجرة البحث الثنائية**، كل عقدة تحقق الشرط التالي:
- جميع العقد في الشجرة الفرعية اليسرى **أصغر** من العقدة الحالية
- جميع العقد في الشجرة الفرعية اليمنى **أكبر** من العقدة الحالية

لذلك، عندما نزور العقد بالترتيب: `يسار ← جذر ← يمين`، نحصل على:
1. أصغر القيم أولاً (من اليسار)
2. ثم القيمة المتوسطة (الجذر)
3. ثم أكبر القيم (من اليمين)

هذا يعطينا **ترتيباً تصاعدياً** طبيعياً !

### 🧮 تطبيقات عملية

#### للاجتياز المسبق:
- **إنشاء نسخة** من الشجرة
- **حفظ الشجرة** في ملف
- **بناء شجرة** من تمثيل نصي

#### للاجتياز المتوسط:
- **طباعة القيم مرتبة** في BST
- **البحث الثنائي** في مصفوفة
- **التحقق** من صحة BST

#### للاجتياز اللاحق:
- **حذف الشجرة** (تحرير الذاكرة)
- **حساب ارتفاع** الشجرة
- **تقييم التعبيرات** الرياضية

---

<div align="center" dir="rtl">
  <b>🌳 أتقن الأشجار الثنائية لتصبح مبرمجاً أفضل ! 🚀</b>
</div>
